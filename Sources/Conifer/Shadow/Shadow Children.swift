// Conifer © 2019–2024 Constantino Tsarouhas

import DepthKit

/// A sequence of shadows of non-foundational child components contained in a parent component.
struct ShadowChildren<Parent : Shadow, Child> : AsyncSequence {	// TODO: Constrain `Child` to `Shadow` when conformance of `any Shadow` to `Shadow` can be defined.
	
	/// The shadow of the parent component whose children are generated by `self`.
	let parent: Parent
	
	// See protocol.
	func makeAsyncIterator() -> AsyncIterator {
		.init(for: parent)
	}
	
	// See protocol.
	struct AsyncIterator : AsyncIteratorProtocol {
		
		/// Creates an iterator of shadows of non-foundational child components of `parent`'s subject.
		fileprivate init(for parent: Parent) {
			self.init(graph: parent.graph, parentLocation: parent.location)
		}
		
		/// Creates an iterator of shadows of non-foundational child components of the component at `parentLocation` in `graph`.
		private init(graph: ShadowGraph, parentLocation: ShadowLocation) {
			self.graph = graph
			self.state = .initial(parentLocation: parentLocation)
		}
		
		/// The graph backing `self`.
		private let graph: ShadowGraph
		
		/// The iterator's state.
		private var state: State
		private enum State {
			
			/// The iterator hasn't been used yet.
			///
			/// - Parameter parentLocation: The absolute location of the parent component.
			case initial(parentLocation: ShadowLocation)
			
			/// The iterator is iterating through the parent component's children.
			///
			/// - Parameter childLocations: A list of absolute locations of already rendered children of the parent component that are to be returned or traversed.
			case shallow(childLocations: ArraySlice<ShadowLocation>)
			
			/// The iterator provides nested children provided by a subiterator before resuming iteration through the parent component's children.
			///
			/// - Parameter 1: An iterator providing nested children.
			/// - Parameter childLocations: A list of absolute locations of already rendered children of the parent component that are to be returned or traversed after processing the nested iterator.
			indirect case deep(AsyncIterator, childLocations: ArraySlice<ShadowLocation>)
			
		}
		
		// See protocol.
		mutating func next() async throws -> Child? {
			switch state {
				
				case .initial(parentLocation: let location):
				state = .shallow(childLocations: try await graph.renderIfNeededChildren(ofComponentAt: location)[...])	// triggers a render if needed
				return try await next()
				
				case .shallow(childLocations: var childLocations):
				guard let childLocation = childLocations.popFirst() else { return nil }
				let child = await graph.prerenderedComponent(at: childLocation)
				if child is any FoundationalComponent {
					state = .deep(.init(graph: graph, parentLocation: childLocation), childLocations: childLocations)	// same Element type
					return try await next()
				} else {
					state = .shallow(childLocations: childLocations)
					let childShadow = child.makeUntypedShadow(graph: graph, location: childLocation)
					return childShadow as? Element !! "Expected child of \(Parent.self) to be \(Element.self); got a \(type(of: childShadow)) instead"
				}
				
				case .deep(var nestedChildren, childLocations: let childLocations):
				if let child = try await nestedChildren.next() {
					state = .deep(nestedChildren, childLocations: childLocations)
					return child
				} else {
					state = .shallow(childLocations: childLocations)
					return try await next()
				}
				
			}
		}
		
	}
	
}
